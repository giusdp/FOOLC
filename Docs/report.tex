\documentclass{scrreprt}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}

\title{Report del Progetto di Compilatori e Interpreti}
\date{Data di Consegna}
\author{Giuseppe De Palma XXXXXX, Eduart Uzeir XXXXXX\\ Domenico Coriale XXXXXX e Andrew Memma XXXXXX\\
\\Corso di Laurea Magistrale in Informatica 2017/2018}
\begin{document}

\maketitle

\tableofcontents

\chapter{Introduzione}
Il lavoro presentato riguarda un compilatore per un semplice linguaggio di programmazione imperativo: FOOL. Il progetto è parte dell'esame del corso ``Compilatori e Intepreti'' della Magistrale in Informatica, Università di Bologna. Il lavoro è stato svolto da 4 studenti del suddetto corso nel periodo estivo del 2018.\\

L'obiettivo di tale progetto è puramente accademico, volto allo studio sullo sviluppo e funzionamento dei compilatori. Partendo dal testo di un programma scritto in FOOL, il compilatore lo analizza sia per ricavarne le informazioni necessarie per generare codice eseguibile, sia per controllarne la correttezza. Si fa uso di diverse tecniche per cercare errori nei programmi (a tempo di compilazione). In particolare, il linguaggio si avvale di un semplice sistema di tipi e il compilatore esegue un controllo di tipi statico che permette di segnalare all'utente errori di tipo. Con questo controllo si ha il vantaggio di evitare i cosiddetti errori \textit{untrapped} e una parte degli errori \textit{trapped}, cioè l'insieme degli errori ``proibiti''.\footnote{Distinguiamo due generi di errore in un programma: errori \textit{trapped}, ovvero quelli che provocano il fallimento della computazione, e gli errori	\textit{untrapped}, che non	presentano sintomi immediatamente visibili, e sono perciò più insidiosi. Al primo tipo appartengono, ad esempio, la divisione per zero o un accesso proibito alla memoria; al secondo la lettura erronea di una porzione non significativa della memoria.}\\

FOOL non è l'unico linguaggio utilizzato, infatti il compilatore deve generare del codice eseguibile (da un elaboratore) partendo da un programma scritto in FOOL. Questo nuovo codice è scritto in un linguaggio \textit{assembly} per una \textit{stack machine} con registri (SVM, che sta per Stack Virtual Machine). Anch'esso usato per scopi accademici, senza un reale utilizzo pratico. Ha istruzioni per alcuni calcoli aritmentici, gestione dello \textit{stack} e salti condizionati. In accordo con le estensioni fatte a FOOL, anche il linguaggio della SVM è stato arricchito.

\section{Outline}
Nei capitoli successivi è presentato in modo approfondito il progetto e le sue caratteristiche principali. In particolare è descritta la struttura del compilatore e come utilizzarlo, per poi mostrare una breve analisi fatta sulle diverse parti che lo costituiscono. Il capitolo 4 discute la grammatica del linguaggio e come da questa si ricavino le informazioni per proseguire con la compilazione. Nel capitolo 5 è discussa l'analisi semantica, di particolare importanza è la sezione del \textit{type checking}. Prima di concludere è descritta, nel capitolo 6, la generazione del codice \textit{assembly}.

\chapter{Descrizione del Progetto}
Si discute brevemente la struttura dei package e delle classi, l'implementazione etc.

\section{Utilizzo}
Si spiega con dettaglio come lanciare e utilizzare il progetto.

\chapter{Analisi Preliminare}

\chapter{Sintassi}
Punto di inizio dello sviluppo. Si discute l'analisi lessicale. La grammatica, la generazione di token.
Non dovrebbe esserci molto da dire siccome la grammatica è già praticamente data e antlr automizza molto.\\
Si discute l'analisi sintattica, l'AST etc. Anche qui sarà breve.\\
Si discute anche l'implementazione dell'AST e le altre parti inerenti alla sintassi.

\chapter{Semantica}
Si discute brevemente lo scopo dell'analisi semantica (attraversare l'albero di sintassi astratta costruito prima, gestione
degli scope e controllo tipi).\\
Si spiega brevemente le decisioni di design per le symbol tables ed il sistema dei tipi (statico).
\section{Type Checking}
sezione importantissimo, qui è dove bisogna essere i più precisi e formali. Si discute per bene lo sviluppo
e implementazione del type checking.

\chapter{Generazione del Codice}
Capitolo sulla code generation. Si discute come si trasforma il codice scritto nella grammatica
ad alto livello di FOOL a codice macchina. Come si gestisce lo stack, i pointers, i frames etc etc.\\
\\
Magari si può dividere questo capitolo con le due sezioni sotto, dipende da come implementiamo la code 
generation. Se la facciamo in due fasi passando prima per una generazione ad un codice intermedio e 
poi al bytecode, allora questo capitolo si scrive con le due sezioni sotto.
La generazione intermedia si fa quando si usa anche un interprete, dipende da come vogliamo fare.
\section{Generazione del Codice Intermedia}
\section{Generazione del Codice}

\chapter{Garbage Collection}
Opzionalmente possiamo fare la garbage collection e verrà discussa qui.

\chapter{Conclusioni}
Brevissimo capitolo conclusivo, si fa un piccolo riassunto di tutto il report e si tirano le somme.
\end{document}