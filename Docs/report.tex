\documentclass{scrreprt}

\usepackage[italian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{multicol}

\usepackage{ebproof}
\usepackage{amssymb}
\usepackage{latexsym}

\usepackage{amsmath}

%\title{Report del Progetto di Compilatori e Interpreti}
%\date{}
%\author{Giuseppe De Palma  \and Andrew Memma  \\ \\Corso di Laurea Magistrale in Informatica}
%0000854846
%1900068459
\begin{document}

\begin{titlepage}
	\centering
	{\scshape\LARGE Alma Mater Studiorum\\Università di Bologna \par}
	\vspace{1cm}
	{\scshape\Large Report\par}
	\vspace{1.5cm}
    {\huge\bfseries Progetto di Compilatori e Interpreti\par}
    \vspace{0.5cm}
    {\scshape\Large Corso di Laurea Magistrale in Informatica\par}
	\vspace{2cm}
    {\Large\itshape Giuseppe De Palma \\0000854846\par}
	\vspace{0.5cm}    
    {\Large\itshape Andrew Memma \\1900068459\par}
    \vfill

% Bottom of the page
	{\large \today\par}
\end{titlepage}

\tableofcontents

\chapter{Introduzione}
Il lavoro presentato riguarda un compilatore per un semplice linguaggio di programmazione ad oggetti: FOOL. Il progetto è parte dell'esame del corso ``Compilatori e Intepreti'' della Magistrale in Informatica, Università di Bologna. Il lavoro è stato svolto da 2 studenti del suddetto corso.\\

L'obiettivo di tale progetto è volto allo studio dello sviluppo e funzionamento dei compilatori. Partendo dal testo di un programma scritto in FOOL, il compilatore lo analizza sia per ricavarne le informazioni necessarie per generare codice eseguibile, sia per controllarne la correttezza. Si fa uso di diverse tecniche per cercare errori nei programmi (a tempo di compilazione). In particolare, il linguaggio si avvale di un semplice sistema di tipi e il compilatore esegue un controllo di tipi statico che permette di segnalare all'utente errori di tipo. Con questo controllo si ha il vantaggio di evitare i cosiddetti errori \textit{untrapped} e una parte degli errori \textit{trapped}, cioè l'insieme degli errori ``proibiti''.\footnote{Distinguiamo due generi di errore in un programma: errori \textit{trapped}, ovvero quelli che provocano il fallimento della computazione, e gli errori	\textit{untrapped}, che non	presentano sintomi immediatamente visibili, e sono perciò più insidiosi. Al primo tipo appartengono, ad esempio, la divisione per zero o un accesso proibito alla memoria; al secondo la lettura erronea di una porzione non significativa della memoria.}\\

FOOL non è l'unico linguaggio utilizzato, infatti il compilatore deve generare del codice eseguibile (da un elaboratore) partendo da un programma scritto in FOOL. Questo nuovo codice è scritto in un linguaggio \textit{assembly} per una \textit{stack virtual machine} con registri (SVM), il quale offre istruzioni per alcuni calcoli aritmentici, per gestione di \textit{stack} e \textit{heap} e salti condizionati. In accordo con le estensioni fatte a FOOL, anche il linguaggio SVM è stato arricchito.

\section{Outline}
Nei capitoli successivi è presentato in modo approfondito il progetto e le sue caratteristiche principali. Nel capitolo successivo viene descritta la struttura del compilatore e come utilizzarlo e una breve analisi sulle diverse parti che lo costituiscono. Il capitolo 3 discute la grammatica del linguaggio e come da questa si ricavano le informazioni per proseguire con la compilazione. Nel capitolo 4 è discussa l'analisi semantica, di particolare importanza è la sezione del \textit{type checking}. Prima di concludere è descritta, nel capitolo 5, la generazione del codice \textit{svm}.

\chapter{Descrizione del Progetto}
\section{Struttura}
Il compilatore è stato sviluppato nel linguaggio di programmazione Java, utilizzando il \textit{tool} Antlr nella sua versione 4.6 per la generazione automatica di \textit{lexer} e \textit{parser}.
Avendo, quindi, definito la grammatica di FOOL (nel file \textit{FOOL.g4}), il \textit{tool} genera le varie classi che permettono di effettuare l'analisi lessicale e sintattica sui programmi scritti in FOOL.
In questo modo la creazione di \textit{tokens} e la creazione dell'albero astratto di sintassi (\textit{Abstract Syntax Tree}) sono già gestite da Antlr, il quale fornisce due metodi per visitare ed utilizzare l'albero: i \textit{visitor} e \textit{listener} design patterns.
Per questo progetto il \textit{visitor pattern} è stato scelto per visitare l'albero ed ottenere il necessario per effettuare l'analisi semantica e la generazione di codice.\\

Il progetto è stato strutturato in diversi package, partendo dal codice fornito dal professore:
\begin{itemize}
    \item ast: contiene le classi che rappresentano i nodi dell'albero visitato con il Visitor di \textit{Antlr}. 
            L'interfaccia Node rappresenta il concetto di nodo dell'albero astratto sintattico, in particolare dichiara tre metodi:
            \textit{checkSemantics}, \textit{typeCheck}, \textit{codeGeneration}. Le classi usate per i vari tipi di nodo implementano questa interfaccia.
    \item codeexecution: si occupa della esecuzione del codice e della gestione della memoria. In particolare la classe \textit{VirtualMachine} interpreta il codice (SVM) generato dalle istruzioni in FOOL.
    \item lib: contiene la libreria \textit{Antlr 4.6}, necessaria per l'esecuzione del compilatore.
    \item parser: contiene \textit{FOOL.g4} e le diverse classi create da \textit{Antlr}.
    \item svm:  contiene \textit{SVM.g4} e le diverse classi create da \textit{Antlr}.
    \item type: contiene le classi che rappresentano i tipi dei costrutti FOOL: \textit{IntType}, \textit{BoolType}, \textit{ClassType}, \textit{VoidType}.
    \item util: contiene in particolare la classe \textit{Enviroment} che offre varie strutture dati di utilità e la \textit{Symbol Table}, e la classe \textit{FOOLlib} che oltre ad alcuni metodi utili
            per la generazione del codice, offre il metodo \text{isSubType} per il controllo dei tipi delle espressioni FOOL.
\end{itemize}

Il file ``CompilerLauncher.java'' è il punto d'entrata del compilatore.

\section{Istruzioni Per l'Utilizzo}
\begin{enumerate}
    \item Importare il progetto in \textit{Eclipse} oppure \textit{IntelliJ}.
    \item Se il progetto presenta problemi, aggiungere nel \textit{Build Path} la libreria \textit{Antlr} contenuta nella cartella \textit{lib}.
        Da Eclipse, tasto destro sulla cartella del progetto, \textit{Configure Build Path} e da lì aggiungere la libreria.
    \item Il file ``prova.fool'' nella cartella \textit{Tests} contiene il codice FOOL che il compilatore utilizza. Scrivere lì il proprio codice. 
        Il compilatore legge il file ``prova.fool'' e, in seguito ai controlli di errori, crea il file ``prova.fool.asm'' con il codice SVM corrispondente.
    \item In caso di errori in un qualunque punto del processo (errori lessicali, sintattici, di scope, di tipi), l'esecuzione verrà interrotta e verrà mostrato l'errore
        nel terminale.
    \item Se nel codice FOOL vengono utilizzati comandi \textit{print}, viene mostrata l'espressione da stampare nel terminale. 
\end{enumerate}

\chapter{Sintassi}
Punto di inizio dello sviluppo. Si discute FOOL.
Si discute l'analisi sintattica, l'AST etc. Anche qui sarà breve.\\
Si discute anche l'implementazione dell'AST e le altre parti inerenti alla sintassi.
\section{FOOL}

\chapter{Semantica}
Si discute brevemente lo scopo dell'analisi semantica (attraversare l'albero di sintassi astratta costruito prima, gestione
degli scope e controllo tipi).
Si spiega brevemente le decisioni di design per le symbol tables ed il sistema dei tipi (statico).
\section{Scope}

\section{Type Checking}
È stato sviluppato un sistema di tipi statico per il linguaggio FOOL. Qui di seguito vengono riportate le varie regole di inferenza.\\

Partendo dalle regole più semplici, FOOL può essere sintetizzato con il linguaggio di espressioni seguente:
\[
\begin{array}{lcl}
N & ::= & 0 \mid 1 \mid \dots\\ 
B & ::= &  true \mid false \\
T & ::= & int \mid bool \\
E & ::= & N \mid B \mid E + E' \mid E - E' \mid E \times E' \mid E \div E' \mid\\
& & E == E' \mid E < E '\mid E > E' \mid E \le E' \mid E \ge E' \mid \\
& & E \lor E' \mid E \land E' \mid \lnot E 
\end{array}
\]

Dove $N$ sono i numeri, $B$ i valori booleani, $T$ il tipo che un'espressione può avere ed $E$ espressioni semplici, aritmetiche e booleane.
\subsection{Regole di Inferenza}

I controlli che il compilatore esegue sulla correttezza delle espressioni usate, sono dati dalle seguenti regole.

\begin{multicols}{2}
\begin{enumerate}

    \item Num Rule
    \[
        \begin{prooftree}
            %\hypo {[Q]}
            \infer [no rule] 0 {\Gamma \vdash Num: int}
        \end{prooftree} 
    \] 
    \item False Rule
    \[
        \begin{prooftree}
            %\hypo {[Q]}
            \infer [no rule] 0 {\Gamma \vdash false: bool}
        \end{prooftree}
    \]
    \item True Rule
    \[
        \begin{prooftree}
            %\hypo {[Q]}
            \infer [no rule] 0 {\Gamma \vdash true: bool}
        \end{prooftree}
    \]
    \item Plus Rule
        \[
            \begin{prooftree}
                \hypo {E : int}
                \hypo {E' : int}
                \infer 2 {\Gamma \vdash E + E' : int}
            \end{prooftree}
        \]
    \item Sub Rule
        \[
            \begin{prooftree}
                \hypo {E : int}
                \hypo {E' : int}
                \infer 2 {\Gamma \vdash E - E' : int}
            \end{prooftree}
        \]
    \item Mult Rule
        \[
            \begin{prooftree}
                \hypo {E : int}
                \hypo {E' : int}
                \infer 2 {\Gamma \vdash E \times E' : int}
            \end{prooftree} [Mul]
        \]
    \item Div Rule
        \[
            \begin{prooftree}
                \hypo {E : int}
                \hypo {E' : int}
                \infer 2 {\Gamma \vdash E \div E' : int}
            \end{prooftree} 
        \]
    \item Equal Rule
        \[
            \begin{prooftree}
                \hypo {E : T}
                \hypo {E' : T}
                \infer 2 {\Gamma \vdash E == E' : bool}
            \end{prooftree} 
        \]
    \item Less Than Rule
        \[
            \begin{prooftree}
                \hypo {E : int}
                \hypo {E' : int}
                \infer 2 {\Gamma \vdash E < E' : bool}
            \end{prooftree} 
        \]
    \item Less Equal Rule
        \[
            \begin{prooftree}
                \hypo {E : int}
                \hypo {E' : int}
                \infer 2 {\Gamma \vdash E \le E' : bool}
            \end{prooftree} 
        \]
    \item Greater Than Rule
        \[
            \begin{prooftree}
                \hypo {E : int}
                \hypo {E' : int}
                \infer 2 {\Gamma \vdash E > E' : bool}
            \end{prooftree} 
        \]
        \item Greater Equal Rule
        \[
            \begin{prooftree}
                \hypo {E : int}
                \hypo {E' : int}
                \infer 2 {\Gamma \vdash E \ge E' : bool}
            \end{prooftree} 
        \]
        \item Or Rule
        \[
            \begin{prooftree}
                \hypo {E : bool}
                \hypo {E' : bool}
                \infer 2 {\Gamma \vdash E \lor E' : bool}
            \end{prooftree} 
        \]
        \item And Rule
        \[
            \begin{prooftree}
                \hypo {E : bool}
                \hypo {E' : bool}
                \infer 2 {\Gamma \vdash E \land E' : bool}
            \end{prooftree} 
        \]
        \item Not Rule
        \[
            \begin{prooftree}
                \hypo {E : bool}
                \infer 1 {\Gamma \vdash \lnot E : bool}
            \end{prooftree} 
        \]

\end{enumerate}
\end{multicols}

\subsection{Altri comandi}

FOOL offre anche comandi di tipo imperativo e orientato agli oggetti, quindi dichiarazioni di variabili, di classi, il costrutto $if$ $then$ $else$.
Il linguaggio mostrato precedentemente viene esteso con questi nuovi comandi.

\[
\begin{array}{lcl}
    D &::=& T$ $id = E\\
    L &::= & $let $T$ $id = E$ in $P \\
    F & ::= & T$ $f(T$ $id)$ $ P\\
    P & ::= & E \mid id \mid id = E \mid $ if $ E $ then $ P $ else $ P' \mid\\
& & $class $C$ extends $C'(T$ $id)$ $F \mid $ new $ C()\\ 
\end{array}
\]

Dove ``$id$'' rappresenta l'utilizzo di una generica variabile che può assumere un valore numerico, booleano o classe.
Essa viene ``dichiarata'' prefissando il tipo alla variabile quando c'è un assegnamento con un'espressione, usando il simbolo $=$. Non dichiarando 
il tipo, invece, il comando diventa uno ``statement'', cioè una assegnazione di una variabile dichiarata in precedenza.
Infine, usiamo $f$, e $C$ per indicare nomi generici che una funzione o una classe possono avere.\\

Di seguito sono elencate alcune delle molte regole utilizzate.

\begin{multicols}{2}
    \begin{enumerate}
        \item Var Rule
    \[
        \begin{prooftree}
            \hypo {\Gamma(id) = T}
            \infer 1 {\Gamma \vdash id: T}
        \end{prooftree}\\
    \]
    \end{enumerate}
\end{multicols}

\chapter{Generazione del Codice}
Capitolo sulla code generation. Si discute come si trasforma il codice scritto nella grammatica
ad alto livello di FOOL a codice macchina. Come si gestisce lo stack, i pointers, i frames etc etc.\\
\\
Magari si può dividere questo capitolo con le due sezioni sotto, dipende da come implementiamo la code 
generation. Se la facciamo in due fasi passando prima per una generazione ad un codice intermedio e 
poi al bytecode, allora questo capitolo si scrive con le due sezioni sotto.
La generazione intermedia si fa quando si usa anche un interprete, dipende da come vogliamo fare.

\section{Heap}
\section{Dispatch Table}
\section{SVM}
\section{Virtual Machine}

\chapter{Conclusioni}
Brevissimo capitolo conclusivo, si fa un piccolo riassunto di tutto il report e si tirano le somme.
\end{document}